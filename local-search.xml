<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>String相关知识</title>
    <link href="/2020/10/String%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2020/10/String%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一、String类型"><a href="#一、String类型" class="headerlink" title="一、String类型"></a>一、String类型</h1><p>String类型在Java中是十分常用的类型，指向一个字符串，如：“ABC”、“123”等。String类是定义于java.lang.string包中的，该包提供了切割、复制、查找等函数。String是一个用 final 声明的常量类，不能被任何类所继承，且无法被修改。</p><h2 id="（一）String不变性"><a href="#（一）String不变性" class="headerlink" title="（一）String不变性"></a>（一）String不变性</h2><p> 关于String类，一个重要的特性是其不可变性，即一个字符串一旦被创建，就不会再被修改。但是显然我们在写代码时，以下句子是可以被通过的：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">String s</span> = <span class="hljs-string">&quot;abcd&quot;</span>;<span class="hljs-attribute">s</span> = <span class="hljs-string">&quot;123&quot;</span>;</code></pre><p>这是因为，这种不可变性指的是其内存中的实现。当我们创建一个字符串时，内存中会创建这样的一个字符串对象的引用。而当我们尝试修改s的内容时，我们并不是修改字符串对象，而是在内存中重新创建了一个字符串对象，并且将指针指向了这个新创建的字符串对象。<br><img src="https://img-blog.csdnimg.cn/20201026110232932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="（二）String在内存中的两种存储方法"><a href="#（二）String在内存中的两种存储方法" class="headerlink" title="（二）String在内存中的两种存储方法"></a>（二）String在内存中的两种存储方法</h2><h3 id="1-存储位置"><a href="#1-存储位置" class="headerlink" title="1.存储位置"></a>1.存储位置</h3><p>String实际上是一个指针（原型为一个char*类型的指针，学过C/C++应该明白），而这个指针存储的位置可以是栈或者堆，这主要是取决于这个字符串被创建的方法，自动创建的变量是存在栈中的，而通过new生成的变量是存储在堆中的。</p><p> 创建方法一：</p><pre><code class="hljs abnf">String str1 = <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-comment">; </span></code></pre><p>步骤： </p><ol><li>栈中开辟一块空间存放引用str1， </li><li>String池中开辟一块空间，存放String常量”abc”， </li><li>引用str1指向池中String常量”abc”， </li><li>str1所指代的地址即常量”abc”所在地址，输出为true </li></ol><p>创建方法二：</p><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> str2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);</code></pre><p>步骤： </p><ol><li>栈中开辟一块空间存放引用str2， </li><li>堆中开辟一块空间存放一个新建的String对象”abc”， </li><li>引用str2指向堆中的新建的String对象”abc”， </li><li>str2所指代的对象地址为堆中地址，而常量”abc”地址在池中，输出为false </li></ol><h3 id="2-存储方式——字符串常量池"><a href="#2-存储方式——字符串常量池" class="headerlink" title="2. 存储方式——字符串常量池"></a>2. 存储方式——字符串常量池</h3><p>在Java的内存分配中，总共3种常量池，分别是Class常量池、运行时常量池、字符串常量池，String类型的对象自然是存在字符串常量池中。</p><p>字符串的分配需要消耗高昂的时间和空间的，而且字符串使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性，常量池中一定不存在两个相同的字符串。</p><p>所以说，如果两个字符串指针指向了同一个字符串，如：</p><pre><code class="hljs abnf">String s = <span class="hljs-string">&quot;abcd&quot;</span><span class="hljs-comment">;</span>String s2 = <span class="hljs-string">&quot;abcd&quot;</span><span class="hljs-comment">;</span></code></pre><p>则会指向字符串常量池中的同一个字符串对象。<br><img src="https://img-blog.csdnimg.cn/20201026113357606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>当String类对字符串进行连接操作时，同样的，也是在字符串常量池中创建了一个新的字符串，并将字符串指针指向了该字符串。</p><pre><code class="hljs ini"><span class="hljs-attr">s</span> = s.concat(<span class="hljs-string">&quot;ef&quot;</span>)<span class="hljs-comment">;</span></code></pre><p><img src="https://img-blog.csdnimg.cn/20201026120412178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="（三）java-lang-String提供的函数"><a href="#（三）java-lang-String提供的函数" class="headerlink" title="（三）java.lang.String提供的函数"></a>（三）java.lang.String提供的函数</h2><p>1    char charAt(int index)<br>返回指定索引处的 char 值。<br>2    int compareTo(Object o)<br>把这个字符串和另一个对象比较。<br>3    int compareTo(String anotherString)<br>按字典顺序比较两个字符串。<br>4    int compareToIgnoreCase(String str)<br>按字典顺序比较两个字符串，不考虑大小写。<br>5    String concat(String str)<br>将指定字符串连接到此字符串的结尾。<br>6    boolean contentEquals(StringBuffer sb)<br>当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。<br>7    static String copyValueOf(char[] data)<br>返回指定数组中表示该字符序列的 String。<br>8    static String copyValueOf(char[] data, int offset, int count)<br>返回指定数组中表示该字符序列的 String。<br>9    boolean endsWith(String suffix)<br>测试此字符串是否以指定的后缀结束。<br>10    boolean equals(Object anObject)<br>将此字符串与指定的对象比较。<br>11    boolean equalsIgnoreCase(String anotherString)<br>将此 String 与另一个 String 比较，不考虑大小写。<br>12    byte[] getBytes()<br> 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。<br>13    byte[] getBytes(String charsetName)<br>使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。<br>14    void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)<br>将字符从此字符串复制到目标字符数组。<br>15    int hashCode()<br>返回此字符串的哈希码。<br>16    int indexOf(int ch)<br>返回指定字符在此字符串中第一次出现处的索引。<br>17    int indexOf(int ch, int fromIndex)<br>返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。<br>18    int indexOf(String str)<br> 返回指定子字符串在此字符串中第一次出现处的索引。<br>19    int indexOf(String str, int fromIndex)<br>返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。<br>20    String intern()<br> 返回字符串对象的规范化表示形式。<br>21    int lastIndexOf(int ch)<br> 返回指定字符在此字符串中最后一次出现处的索引。<br>22    int lastIndexOf(int ch, int fromIndex)<br>返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。<br>23    int lastIndexOf(String str)<br>返回指定子字符串在此字符串中最右边出现处的索引。<br>24    int lastIndexOf(String str, int fromIndex)<br> 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。<br>25    int length()<br>返回此字符串的长度。<br>26    boolean matches(String regex)<br>告知此字符串是否匹配给定的正则表达式。<br>27    boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)<br>测试两个字符串区域是否相等。<br>28    boolean regionMatches(int toffset, String other, int ooffset, int len)<br>测试两个字符串区域是否相等。<br>29    String replace(char oldChar, char newChar)<br>返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。<br>30    String replaceAll(String regex, String replacement)<br>使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。<br>31    String replaceFirst(String regex, String replacement)<br> 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。<br>32    String[] split(String regex)<br>根据给定正则表达式的匹配拆分此字符串。<br>33    String[] split(String regex, int limit)<br>根据匹配给定的正则表达式来拆分此字符串。<br>34    boolean startsWith(String prefix)<br>测试此字符串是否以指定的前缀开始。<br>35    boolean startsWith(String prefix, int toffset)<br>测试此字符串从指定索引开始的子字符串是否以指定前缀开始。<br>36    CharSequence subSequence(int beginIndex, int endIndex)<br> 返回一个新的字符序列，它是此序列的一个子序列。<br>37    String substring(int beginIndex)<br>返回一个新的字符串，它是此字符串的一个子字符串。<br>38    String substring(int beginIndex, int endIndex)<br>返回一个新字符串，它是此字符串的一个子字符串。<br>39    char[] toCharArray()<br>将此字符串转换为一个新的字符数组。<br>40    String toLowerCase()<br>使用默认语言环境的规则将此 String 中的所有字符都转换为小写。<br>41    String toLowerCase(Locale locale)<br> 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。<br>42    String toString()<br> 返回此对象本身（它已经是一个字符串！）。<br>43    String toUpperCase()<br>使用默认语言环境的规则将此 String 中的所有字符都转换为大写。<br>44    String toUpperCase(Locale locale)<br>使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。<br>45    String trim()<br>返回字符串的副本，忽略前导空白和尾部空白。<br>46    static String valueOf(primitive data type x)<br>返回给定data type类型x参数的字符串表示形式。<br>47    contains(CharSequence chars)<br>判断是否包含指定的字符系列。<br>48    isEmpty()<br>判断字符串是否为空。</p><h1 id="二、StringBuilder"><a href="#二、StringBuilder" class="headerlink" title="二、StringBuilder"></a>二、StringBuilder</h1><p>StringBuffer类也代表字符串, 内部实现跟String不一样。</p><h2 id="（一）StringBuilder的存储方法"><a href="#（一）StringBuilder的存储方法" class="headerlink" title="（一）StringBuilder的存储方法"></a>（一）StringBuilder的存储方法</h2><p>StringBuilder的继承结构如下：<br><img src="https://img-blog.csdnimg.cn/20201026121521701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>StringBuilder对象则代表一个字符序列可变的字符串，StringBuilder内部维护了一个char[]类型的value，当我们要修改指向的字符串时可通过StringBuilder提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列，而非创建一个新的String对象。一旦通过StringBuilder生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。这种存储方式使得存储的字符串更少，因此拥有更高的效率和更少的存储空间。当我们想要连接两个字符串时进行的操作如下图：<br><img src="https://img-blog.csdnimg.cn/20201026121809565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在StringBuilder中如果数组的剩余容量，无法添加全部内容，则通过expandCapacity(int minimumCapacity)方法对value进行扩容，其中minimumCapacity = 原value长度 + append添加的内容长度。<br>1、扩大容量为原来的两倍 + 2，为什么要 + 2，而不是刚好两倍？<br>2、如果扩容之后，还是无法添加全部内容，则将 minimumCapacity 作为最终的容量大小；<br>3、利用 System.arraycopy 方法对原value数据进行复制；<br>在使用StringBuilder时，如果给定一个合适的初始值，可以避免由于char[]数组多次复制而导致的性能问题。</p><h2 id="（二）java-lag-StrigBuilder提供的函数"><a href="#（二）java-lag-StrigBuilder提供的函数" class="headerlink" title="（二）java.lag.StrigBuilder提供的函数"></a>（二）java.lag.StrigBuilder提供的函数</h2><p>一、创建Stringbuilder对象<br>StringBuilder strB = new StringBuilder();</p><p>1 append(String str)/append(Char c)<br>字符串连接<br>2 toString()<br>返回一个与构建起或缓冲器内容相同的字符串<br>3 appendcodePoint(int cp)<br>追加一个代码点，并将其转换为一个或两个代码单元并返回this<br>4 setCharAt(int i, char c)<br>将第 i 个代码单元设置为 c（可以理解为替换）char字符使用  ‘   ’<br>5 insert(int offset, String str)/insert(int offset, Char c)<br>在指定位置之前插入字符(串)<br>6 delete(int startIndex,int endIndex)<br>删除起始位置（含）到结尾位置（不含）之间的字符串</p><h1 id="三、StringBuffer"><a href="#三、StringBuffer" class="headerlink" title="三、StringBuffer"></a>三、StringBuffer</h1><p>StringBuffer和StringBuilder类似，提供了几乎同样的函数，不同的是：StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。</p><p>线程安全的实现是通过synchronized实现的，StringBuffer类中的方法都添加了synchronized关键字，也就是给这个方法添加了一个锁，用来保证线程安全。<br><img src="https://img-blog.csdnimg.cn/2020102612315195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>但是线程安全的实现必然会带来时间性能上的减弱。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Sting、StringBuilder、StringBuffer三者均用于实现字符串，但由于其字符串存储方法的不同，三者时间性能上从优到差为StringBuilder&gt;StringBuffer&gt;String。所以：<br>（1）如果要操作少量的数据用 String；<br>（2）多线程操作字符串缓冲区下操作大量数据 StringBuffer；<br>（3）单线程操作字符串缓冲区下操作大量数据 StringBuilder。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>String,StringBuilder,StringBuffer</title>
    <link href="/2020/10/String-StringBuilder-StringBuffer/"/>
    <url>/2020/10/String-StringBuilder-StringBuffer/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java知识点总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-JAVA -基础知识 -String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1</title>
    <link href="/2020/10/1/"/>
    <url>/2020/10/1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、String类型"><a href="#一、String类型" class="headerlink" title="一、String类型"></a>一、String类型</h1><p>String类型在Java中是十分常用的类型，指向一个字符串，如：“ABC”、“123”等。String类是定义于java.lang.string包中的，该包提供了切割、复制、查找等函数。String是一个用 final 声明的常量类，不能被任何类所继承，且无法被修改。</p><h2 id="（一）String不变性"><a href="#（一）String不变性" class="headerlink" title="（一）String不变性"></a>（一）String不变性</h2><p> 关于String类，一个重要的特性是其不可变性，即一个字符串一旦被创建，就不会再被修改。但是显然我们在写代码时，以下句子是可以被通过的：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">String s</span> = <span class="hljs-string">&quot;abcd&quot;</span>;<span class="hljs-attribute">s</span> = <span class="hljs-string">&quot;123&quot;</span>;</code></pre><p>这是因为，这种不可变性指的是其内存中的实现。当我们创建一个字符串时，内存中会创建这样的一个字符串对象的引用。而当我们尝试修改s的内容时，我们并不是修改字符串对象，而是在内存中重新创建了一个字符串对象，并且将指针指向了这个新创建的字符串对象。<br><img src="https://img-blog.csdnimg.cn/20201026110232932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="（二）String在内存中的两种存储方法"><a href="#（二）String在内存中的两种存储方法" class="headerlink" title="（二）String在内存中的两种存储方法"></a>（二）String在内存中的两种存储方法</h2><h3 id="1-存储位置"><a href="#1-存储位置" class="headerlink" title="1.存储位置"></a>1.存储位置</h3><p>String实际上是一个指针（原型为一个char*类型的指针，学过C/C++应该明白），而这个指针存储的位置可以是栈或者堆，这主要是取决于这个字符串被创建的方法，自动创建的变量是存在栈中的，而通过new生成的变量是存储在堆中的。</p><p> 创建方法一：</p><pre><code class="hljs abnf">String str1 = <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-comment">; </span></code></pre><p>步骤： </p><ol><li>栈中开辟一块空间存放引用str1， </li><li>String池中开辟一块空间，存放String常量”abc”， </li><li>引用str1指向池中String常量”abc”， </li><li>str1所指代的地址即常量”abc”所在地址，输出为true </li></ol><p>创建方法二：</p><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> str2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);</code></pre><p>步骤： </p><ol><li>栈中开辟一块空间存放引用str2， </li><li>堆中开辟一块空间存放一个新建的String对象”abc”， </li><li>引用str2指向堆中的新建的String对象”abc”， </li><li>str2所指代的对象地址为堆中地址，而常量”abc”地址在池中，输出为false </li></ol><h3 id="2-存储方式——字符串常量池"><a href="#2-存储方式——字符串常量池" class="headerlink" title="2. 存储方式——字符串常量池"></a>2. 存储方式——字符串常量池</h3><p>在Java的内存分配中，总共3种常量池，分别是Class常量池、运行时常量池、字符串常量池，String类型的对象自然是存在字符串常量池中。</p><p>字符串的分配需要消耗高昂的时间和空间的，而且字符串使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性，常量池中一定不存在两个相同的字符串。</p><p>所以说，如果两个字符串指针指向了同一个字符串，如：</p><pre><code class="hljs abnf">String s = <span class="hljs-string">&quot;abcd&quot;</span><span class="hljs-comment">;</span>String s2 = <span class="hljs-string">&quot;abcd&quot;</span><span class="hljs-comment">;</span></code></pre><p>则会指向字符串常量池中的同一个字符串对象。<br><img src="https://img-blog.csdnimg.cn/20201026113357606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>当String类对字符串进行连接操作时，同样的，也是在字符串常量池中创建了一个新的字符串，并将字符串指针指向了该字符串。</p><pre><code class="hljs ini"><span class="hljs-attr">s</span> = s.concat(<span class="hljs-string">&quot;ef&quot;</span>)<span class="hljs-comment">;</span></code></pre><p><img src="https://img-blog.csdnimg.cn/20201026120412178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="（三）java-lang-String提供的函数"><a href="#（三）java-lang-String提供的函数" class="headerlink" title="（三）java.lang.String提供的函数"></a>（三）java.lang.String提供的函数</h2><p>1    char charAt(int index)<br>返回指定索引处的 char 值。<br>2    int compareTo(Object o)<br>把这个字符串和另一个对象比较。<br>3    int compareTo(String anotherString)<br>按字典顺序比较两个字符串。<br>4    int compareToIgnoreCase(String str)<br>按字典顺序比较两个字符串，不考虑大小写。<br>5    String concat(String str)<br>将指定字符串连接到此字符串的结尾。<br>6    boolean contentEquals(StringBuffer sb)<br>当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。<br>7    static String copyValueOf(char[] data)<br>返回指定数组中表示该字符序列的 String。<br>8    static String copyValueOf(char[] data, int offset, int count)<br>返回指定数组中表示该字符序列的 String。<br>9    boolean endsWith(String suffix)<br>测试此字符串是否以指定的后缀结束。<br>10    boolean equals(Object anObject)<br>将此字符串与指定的对象比较。<br>11    boolean equalsIgnoreCase(String anotherString)<br>将此 String 与另一个 String 比较，不考虑大小写。<br>12    byte[] getBytes()<br> 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。<br>13    byte[] getBytes(String charsetName)<br>使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。<br>14    void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)<br>将字符从此字符串复制到目标字符数组。<br>15    int hashCode()<br>返回此字符串的哈希码。<br>16    int indexOf(int ch)<br>返回指定字符在此字符串中第一次出现处的索引。<br>17    int indexOf(int ch, int fromIndex)<br>返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。<br>18    int indexOf(String str)<br> 返回指定子字符串在此字符串中第一次出现处的索引。<br>19    int indexOf(String str, int fromIndex)<br>返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。<br>20    String intern()<br> 返回字符串对象的规范化表示形式。<br>21    int lastIndexOf(int ch)<br> 返回指定字符在此字符串中最后一次出现处的索引。<br>22    int lastIndexOf(int ch, int fromIndex)<br>返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。<br>23    int lastIndexOf(String str)<br>返回指定子字符串在此字符串中最右边出现处的索引。<br>24    int lastIndexOf(String str, int fromIndex)<br> 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。<br>25    int length()<br>返回此字符串的长度。<br>26    boolean matches(String regex)<br>告知此字符串是否匹配给定的正则表达式。<br>27    boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)<br>测试两个字符串区域是否相等。<br>28    boolean regionMatches(int toffset, String other, int ooffset, int len)<br>测试两个字符串区域是否相等。<br>29    String replace(char oldChar, char newChar)<br>返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。<br>30    String replaceAll(String regex, String replacement)<br>使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。<br>31    String replaceFirst(String regex, String replacement)<br> 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。<br>32    String[] split(String regex)<br>根据给定正则表达式的匹配拆分此字符串。<br>33    String[] split(String regex, int limit)<br>根据匹配给定的正则表达式来拆分此字符串。<br>34    boolean startsWith(String prefix)<br>测试此字符串是否以指定的前缀开始。<br>35    boolean startsWith(String prefix, int toffset)<br>测试此字符串从指定索引开始的子字符串是否以指定前缀开始。<br>36    CharSequence subSequence(int beginIndex, int endIndex)<br> 返回一个新的字符序列，它是此序列的一个子序列。<br>37    String substring(int beginIndex)<br>返回一个新的字符串，它是此字符串的一个子字符串。<br>38    String substring(int beginIndex, int endIndex)<br>返回一个新字符串，它是此字符串的一个子字符串。<br>39    char[] toCharArray()<br>将此字符串转换为一个新的字符数组。<br>40    String toLowerCase()<br>使用默认语言环境的规则将此 String 中的所有字符都转换为小写。<br>41    String toLowerCase(Locale locale)<br> 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。<br>42    String toString()<br> 返回此对象本身（它已经是一个字符串！）。<br>43    String toUpperCase()<br>使用默认语言环境的规则将此 String 中的所有字符都转换为大写。<br>44    String toUpperCase(Locale locale)<br>使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。<br>45    String trim()<br>返回字符串的副本，忽略前导空白和尾部空白。<br>46    static String valueOf(primitive data type x)<br>返回给定data type类型x参数的字符串表示形式。<br>47    contains(CharSequence chars)<br>判断是否包含指定的字符系列。<br>48    isEmpty()<br>判断字符串是否为空。</p><h1 id="二、StringBuilder"><a href="#二、StringBuilder" class="headerlink" title="二、StringBuilder"></a>二、StringBuilder</h1><p>StringBuffer类也代表字符串, 内部实现跟String不一样。</p><h2 id="（一）StringBuilder的存储方法"><a href="#（一）StringBuilder的存储方法" class="headerlink" title="（一）StringBuilder的存储方法"></a>（一）StringBuilder的存储方法</h2><p>StringBuilder的继承结构如下：<br><img src="https://img-blog.csdnimg.cn/20201026121521701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>StringBuilder对象则代表一个字符序列可变的字符串，StringBuilder内部维护了一个char[]类型的value，当我们要修改指向的字符串时可通过StringBuilder提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列，而非创建一个新的String对象。一旦通过StringBuilder生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。这种存储方式使得存储的字符串更少，因此拥有更高的效率和更少的存储空间。当我们想要连接两个字符串时进行的操作如下图：<br><img src="https://img-blog.csdnimg.cn/20201026121809565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在StringBuilder中如果数组的剩余容量，无法添加全部内容，则通过expandCapacity(int minimumCapacity)方法对value进行扩容，其中minimumCapacity = 原value长度 + append添加的内容长度。<br>1、扩大容量为原来的两倍 + 2，为什么要 + 2，而不是刚好两倍？<br>2、如果扩容之后，还是无法添加全部内容，则将 minimumCapacity 作为最终的容量大小；<br>3、利用 System.arraycopy 方法对原value数据进行复制；<br>在使用StringBuilder时，如果给定一个合适的初始值，可以避免由于char[]数组多次复制而导致的性能问题。</p><h2 id="（二）java-lag-StrigBuilder提供的函数"><a href="#（二）java-lag-StrigBuilder提供的函数" class="headerlink" title="（二）java.lag.StrigBuilder提供的函数"></a>（二）java.lag.StrigBuilder提供的函数</h2><p>一、创建Stringbuilder对象<br>StringBuilder strB = new StringBuilder();</p><p>1 append(String str)/append(Char c)<br>字符串连接<br>2 toString()<br>返回一个与构建起或缓冲器内容相同的字符串<br>3 appendcodePoint(int cp)<br>追加一个代码点，并将其转换为一个或两个代码单元并返回this<br>4 setCharAt(int i, char c)<br>将第 i 个代码单元设置为 c（可以理解为替换）char字符使用  ‘   ’<br>5 insert(int offset, String str)/insert(int offset, Char c)<br>在指定位置之前插入字符(串)<br>6 delete(int startIndex,int endIndex)<br>删除起始位置（含）到结尾位置（不含）之间的字符串</p><h1 id="三、StringBuffer"><a href="#三、StringBuffer" class="headerlink" title="三、StringBuffer"></a>三、StringBuffer</h1><p>StringBuffer和StringBuilder类似，提供了几乎同样的函数，不同的是：StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。</p><p>线程安全的实现是通过synchronized实现的，StringBuffer类中的方法都添加了synchronized关键字，也就是给这个方法添加了一个锁，用来保证线程安全。<br><img src="https://img-blog.csdnimg.cn/2020102612315195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>但是线程安全的实现必然会带来时间性能上的减弱。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Sting、StringBuilder、StringBuffer三者均用于实现字符串，但由于其字符串存储方法的不同，三者时间性能上从优到差为StringBuilder&gt;StringBuffer&gt;String。所以：<br>（1）如果要操作少量的数据用 String；<br>（2）多线程操作字符串缓冲区下操作大量数据 StringBuffer；<br>（3）单线程操作字符串缓冲区下操作大量数据 StringBuilder。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>123</title>
    <link href="/2020/10/123/"/>
    <url>/2020/10/123/</url>
    
    <content type="html"><![CDATA[<p>测试</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>黄大彪</title>
    <link href="/2020/10/%E9%BB%84%E5%A4%A7%E5%BD%AA/"/>
    <url>/2020/10/%E9%BB%84%E5%A4%A7%E5%BD%AA/</url>
    
    <content type="html"><![CDATA[<p>这是一个markdown文档<br>我真棒</p>]]></content>
    
    
    <categories>
      
      <category>黄大彪的一生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-你猜</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/2020/10/%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/10/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java</title>
    <link href="/2020/10/Java/"/>
    <url>/2020/10/Java/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java知识点总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-Java -基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/10/hello-world/"/>
    <url>/2020/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
