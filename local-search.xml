<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java 类与接口</title>
    <link href="/2020/10/Java%20%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
    <url>/2020/10/Java%20%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="一、类"><a href="#一、类" class="headerlink" title="一、类"></a>一、类</h1><p>Java是一门面向对象的编程语言，除了基本数据类型以外，Java要求每一个数据类型必须都是一个类。</p><p>类是对某一类事物的描述，是抽象的、概念上的定义；对象是实际存在的该类事物的个体，因而也称实例（Instance）。类和对象就如同概念和实物之间的关系一样，类就好比是一个模板，而对象就是该模板下的一个实例。</p><h2 id="（一）类的基本用法"><a href="#（一）类的基本用法" class="headerlink" title="（一）类的基本用法"></a>（一）类的基本用法</h2><p>这部分应该大家都会有所涉猎，大家可以选择性看一下</p><h3 id="1-类的定义"><a href="#1-类的定义" class="headerlink" title="1.类的定义"></a>1.类的定义</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名称 </span>&#123;<span class="hljs-comment">//声明成员变量</span><span class="hljs-comment">//声明成员方法</span>&#125;</code></pre><h3 id="2-对象声明"><a href="#2-对象声明" class="headerlink" title="2.对象声明"></a>2.对象声明</h3><p>类定义完成之后，肯定无法直接使用。如果要使用，必须依靠对象，那么由于类属于引用数据类型，所以对象的产生格式（两种格式）如下：<br>（1）格式一：声明并实例化对象</p><pre><code class="hljs java">类名称 对象名称 = <span class="hljs-keyword">new</span> 类名称 () ;</code></pre><p>（2）格式二：先声明对象，然后实例化对象：</p><pre><code class="hljs java">类名称 对象名称 = <span class="hljs-keyword">null</span> ;对象名称 = <span class="hljs-keyword">new</span> 类名称 () ;</code></pre><p>引用数据类型与基本数据类型最大的不同在于：引用数据类型需要内存的分配和使用。所以，关键字new的主要功能就是分配内存空间，也就是说，<strong>只要使用引用数据类型，就要使用关键字new来分配内存空间</strong>。</p><p>当一个实例化对象产生之后，可以按照如下的方式进行类的操作：<br>对象.属性：表示调用类之中的属性；<br>对象.方法()：表示调用类之中的方法。</p><h3 id="3-存储位置"><a href="#3-存储位置" class="headerlink" title="3. 存储位置"></a>3. 存储位置</h3><p>在java中的内存存储方式是这样的：<br>（1）堆内存：保存对象的属性内容。堆内存需要用new关键字来分配空间；<br>（2）栈内存：保存的是堆内存的地址（在这里为了分析方便，<strong>可以简单理解为栈内存保存的是对象的名字</strong>）。</p><h2 id="（二）类的特性"><a href="#（二）类的特性" class="headerlink" title="（二）类的特性"></a>（二）类的特性</h2><p>类的三大特征为：继承、多态、封装。另外他还具有其他一些属性。</p><h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1.继承"></a>1.继承</h3><p>在下面代码中，Person为父类，Man为继承了Person的子类。继承的方法是在子类声明时加上一个关键词<strong>extends</strong> 父类。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;             &#125;&#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Man</span><span class="hljs-params">()</span> </span>&#123;             &#125;&#125;</code></pre><p>继承后子类与父类的关系包括：<br>（1）子类拥有父类<strong>非 private 的属性、方法。</strong><br>（2）子类可以拥有自己的属性和方法，即子类可以对父类进行扩展，即重写函数。（若子类要调用父类中的同名函数，可以使用super代指父类）</p><blockquote><p>重写的条件：</p><p>a.参数列表与被重写方法的参数列表必须完全相同。<br>b.<strong>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类</strong>（java5及更早版本返回类型要一样，java7 及更高版本可以不同）。<br>c.<strong>访问权限不能比父类中被重写的方法的访问权限更低</strong>。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。<br> d.父类的成员方法只能被它的子类重写。<br> e.声明为 final 的方法不能被重写。<br> f.声明为 static 的方法不能被重写，但是能够被再次声明。<br> g.子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。<br>h.重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，<strong>重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常</strong>，反之则可以。<br>i.构造方法不能被重写。</p></blockquote><p>（3）子类可以用自己的方式实现父类的方法。<br>（4）Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。<br>（5）提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</p><h3 id="2-多态"><a href="#2-多态" class="headerlink" title="2.多态"></a>2.多态</h3><p>多态是指，同一个方法的调用，因为对象的不同有不同的行为。</p><p>Java实现多态有三个必要条件：继承、重写、向上转型。</p><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。</p><p>多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      show(<span class="hljs-keyword">new</span> Cat());  <span class="hljs-comment">// 以 Cat 对象调用 show 方法</span>      show(<span class="hljs-keyword">new</span> Dog());  <span class="hljs-comment">// 以 Dog 对象调用 show 方法</span>                      Animal a = <span class="hljs-keyword">new</span> Cat();  <span class="hljs-comment">// 向上转型  </span>      a.eat();               <span class="hljs-comment">// cat是animal的子类，调用的是 Cat 的 eat</span>      Cat c = (Cat)a;        <span class="hljs-comment">// 向下转型  </span>      c.work();        <span class="hljs-comment">// 调用的是 Cat 的 work</span>  &#125;                  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Animal a)</span>  </span>&#123;      a.eat();          <span class="hljs-comment">// 类型判断</span>        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Cat)  &#123;  <span class="hljs-comment">// 猫做的事情 </span>            Cat c = (Cat)a;              c.work();          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Dog) &#123; <span class="hljs-comment">// 狗做的事情 </span>            Dog c = (Dog)a;              c.work();          &#125;      &#125;  &#125; <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;  &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);      &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">&quot;抓老鼠&quot;</span>);      &#125;  &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">&quot;吃骨头&quot;</span>);      &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;          System.out.println(<span class="hljs-string">&quot;看家&quot;</span>);      &#125;  &#125;</code></pre><h3 id="3-封装"><a href="#3-封装" class="headerlink" title="3.封装"></a>3.封装</h3><p>封装是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法，利用的是不同函数的权限设置。</p><p>封装具有以下优点：<br>a. 良好的封装能够减少耦合。</p><p>b. 类内部的结构可以自由修改。</p><p>c. 可以对成员变量进行更精确的控制。</p><p>d. 隐藏信息，实现细节。</p><p>对于函数的权限控制有以下三种关键词：<strong>public private protected</strong><br>public：所有用户均可调用<br>protected：包内可见<br>private：仅自己类可见</p><blockquote><p>附赠几个常见的函数修饰词区分：<br>    public、private、protected、default、static、final</p><ol><li>   final：定义不可修改的变量、方法和类<br>常量修饰符<br>修饰变量不可变<br>修饰方法，则该方法不能被子类重写<br>修饰类，不能被继承</li><li>private、protected、public：<br>修饰函数的可见权限</li><li>static：静态，修饰函数、方法存在的周期<br>被修饰的函数、方法属于类，而非对象，只有当整个类都被丢弃时，才会释放。</li></ol></blockquote><h3 id="4-抽象"><a href="#4-抽象" class="headerlink" title="4.抽象"></a>4.抽象</h3><p>抽象就是只有定义，没有实现的类或方法。关键字是abstract。<br>注意：<br>（1）包含抽象方法的类必须是抽象类，但是抽象类中也可以有普通的方法。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>&#123;   <span class="hljs-keyword">private</span> String name;   <span class="hljs-keyword">private</span> String address;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">computePay</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">//其余代码</span>&#125;</code></pre><p>（2）抽象方法在父类中虽然没有实现，但是在其子类中必须实现。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Salary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary; <span class="hljs-comment">// Annual salary</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">computePay</span><span class="hljs-params">()</span></span><span class="hljs-function">   </span>&#123;      System.out.println(<span class="hljs-string">&quot;Computing salary pay for &quot;</span> + getName());      <span class="hljs-keyword">return</span> salary/<span class="hljs-number">52</span>;   &#125;    <span class="hljs-comment">//其余代码</span>&#125;</code></pre><p>抽象类的使用具有以下要求：<br>a. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p><p>b. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p><p>c. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p><p>d. <strong>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</strong>因为它不能被继承</p><p>e. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，<strong>除非该子类也是抽象类。</strong></p><h1 id="二、接口"><a href="#二、接口" class="headerlink" title="二、接口"></a>二、接口</h1><h2 id="（一）什么是接口"><a href="#（一）什么是接口" class="headerlink" title="（一）什么是接口"></a>（一）什么是接口</h2><p>接口是比抽象类更抽象的类，其中不包含任何的函数实现。关键字为Interface，不用class。接口实现了规范与具体实现的分离。</p><pre><code class="hljs java"><span class="hljs-comment">/* 文件名 : NameOfInterface.java */</span><span class="hljs-keyword">import</span> java.lang.*;<span class="hljs-comment">//引入包</span> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">NameOfInterface</span></span><span class="hljs-class"></span>&#123;   <span class="hljs-comment">//任何类型 final, static 字段</span>   <span class="hljs-comment">//抽象方法</span>&#125;</code></pre><p>接口具有以下特性：<br>1.接口是隐式抽象的，当声明一个接口的时候，<strong>不必使用abstract关键字</strong>。<br>2.接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。<br>3.接口中的方法<strong>都是公有的</strong>。</p><h2 id="（二）接口的实现"><a href="#（二）接口的实现" class="headerlink" title="（二）接口的实现"></a>（二）接口的实现</h2><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。<br>类使用implements关键字实现接口。在类声明中，<strong>Implements关键字放在class声明后面</strong>。<br>实现一个接口的语法，可以使用这个公式：</p><pre><code class="hljs java">...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...</code></pre><p>接口中的变量会被隐式地指定为<strong>public static final</strong>变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是<strong>public abstract</strong>方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误）</p><p>重写接口中声明的方法时，需要注意以下规则：<br>1.类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。<br>2.类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。<br>3.如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</p><p>在实现接口的时候，也要注意一些规则：<br>1.一个类可以同时实现多个接口。<br>2.一个类只能继承一个类，<strong>但是能实现多个接口。</strong><br>3.<strong>一个接口能继承另一个接口</strong>（接口之间是可继承的，这与类是一样的），这和类之间的继承比较相似。</p><h1 id="三、抽象类与接口的区别"><a href="#三、抽象类与接口的区别" class="headerlink" title="***三、抽象类与接口的区别"></a>***三、抽象类与接口的区别</h1><p>1.语法层面上的区别</p><p>　　1）抽象类可以提供某些非abstract的成员方法的实现细节，而接口中只能存在public abstract 方法；</p><p>　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</p><p>　　3）接口中不能含有<strong>静态代码块以及静态方法</strong>，而抽象类可以有静态代码块和静态方法；</p><p>　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><p>2.设计层面上的区别</p><p>　　1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类<strong>整体</strong>进行抽象，包括属性、行为，但是接口却是对类<strong>局部（行为）</strong>进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p><p>　　2）设计层面不同，抽象类作为很多子类的父类，它是一种<strong>模板式设计</strong>。而接口是一种<strong>行为规范</strong>，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>]]></content>
    
    
    <categories>
      
      <category>Java知识点总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-JAVA -基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 如何理解泛型</title>
    <link href="/2020/10/Java%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B/"/>
    <url>/2020/10/Java%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一、什么是泛型"><a href="#一、什么是泛型" class="headerlink" title="一、什么是泛型"></a>一、什么是泛型</h1><p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><p>如下面一段代码中，<String>部分就是一个泛型的应用，类型String被像参数一样传递了。</p><pre><code class="hljs java">List&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();</code></pre><h1 id="二、为什么要用泛型"><a href="#二、为什么要用泛型" class="headerlink" title="二、为什么要用泛型"></a>二、为什么要用泛型</h1><p>早期Java是使用Object来代表任意类型的，但是向下转型有强转的问题，这样程序就不太安全<br>（强转：子类到父类可以很自然的转化，但是父类到子类就必须通过强制类型转化。）</p><p>首先，我们来试想一下：没有泛型，集合会怎么样<br>强转是非常危险的：Collection、Map集合对元素的类型是没有任何限制的。本来我的Collection集合装载的是全部的Dog对象，但是外边把Cat对象存储到集合中，是没有任何语法错误的（因为Dog和Cat均为其子类）。</p><p>把对象扔进集合中，集合是不知道元素的类型是什么的，仅仅知道是Object。因此在get()的时候，返回的是Object。外边获取该对象，还需要强制转换。</p><p>而使用泛型后，返回的值就只能被强转为某一特定类型，就不会出现上述问题了。</p><p>所以泛型的优点有：<br>1.代码更加简洁【不用强制转换】<br>2.程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】<br>3.可读性和稳定性【在编写集合的时候，就限定了类型】</p><h1 id="三、如何使用泛型"><a href="#三、如何使用泛型" class="headerlink" title="三、如何使用泛型"></a>三、如何使用泛型</h1><h2 id="（一）泛型的语法"><a href="#（一）泛型的语法" class="headerlink" title="（一）泛型的语法"></a>（一）泛型的语法</h2><p>泛型类的语法形式：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">name</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>, ..., <span class="hljs-title">Tn</span>&gt; </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;</code></pre><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。由尖括号（&lt;&gt;）分隔的类型参数部分跟在类名后面。它指定类型参数（也称为类型变量）T1，T2，…和 Tn。在实际应用中T1…Tn常使用T、E、V。如下面代码，该代码是基于泛型定义一个链表。</p><pre><code class="hljs java"><span class="hljs-comment">/*1.泛型类*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;    <span class="hljs-keyword">public</span> E data;    <span class="hljs-keyword">public</span> ListNode next;    <span class="hljs-keyword">public</span> ListNode previous;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListNode</span> <span class="hljs-params">(E d)</span></span>&#123;        <span class="hljs-keyword">this</span>.data = d;        <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">this</span>.previous = <span class="hljs-keyword">null</span>;    &#125;&#125;<span class="hljs-comment">//链表</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    <span class="hljs-keyword">public</span> ListNode first;    <span class="hljs-keyword">public</span> ListNode last;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> size;    <span class="hljs-comment">//初始化函数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">()</span></span>&#123;        first=last=<span class="hljs-keyword">null</span>;        size = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//添加一个节点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E num)</span></span>&#123;        ListNode node = <span class="hljs-keyword">new</span> ListNode(num);        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)&#123;            node.next = <span class="hljs-keyword">null</span>;            node.previous = <span class="hljs-keyword">null</span>;            first =  last = node;            size = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span>&#123;            last.next = node;            node.previous = last;            last = node;            size ++;        &#125;    &#125;    <span class="hljs-comment">//移除一个节点</span>    <span class="hljs-comment">/*2.泛型方法*/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(E num)</span></span>&#123;        ListNode cur = first;        <span class="hljs-keyword">while</span>(cur.data != num)&#123;            cur=cur.next;        &#125;        <span class="hljs-comment">//当前结点就是要移除的节点</span>        cur.previous.next = cur.next;        cur.next.previous = cur.previous;        <span class="hljs-keyword">return</span> (E) cur.data;<span class="hljs-comment">//强制类型转化</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;        ListNode cur = first;        <span class="hljs-keyword">while</span>(cur != last)&#123;            System.out.println(cur.data);            cur = cur.next;        &#125;        System.out.println(cur.data);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList();        ll.add(<span class="hljs-number">1</span>);        ll.add(<span class="hljs-number">2</span>);        ll.add(<span class="hljs-number">3</span>);        ll.show();        ll.remove(<span class="hljs-number">2</span>);        ll.show();    &#125;&#125;</code></pre><p>在泛型的&lt;&gt;中，使用的是引用类型而非常见的基本类型，二者的对应如下：<br><img src="https://img-blog.csdnimg.cn/20201027162257644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="（二）泛型的使用"><a href="#（二）泛型的使用" class="headerlink" title="（二）泛型的使用"></a>（二）泛型的使用</h2><p>泛型常用于泛型类、泛型方法、泛型接口三种情况。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。<br>如上面的代码中，ListNode、LinkedList就是使用了泛型的泛型类。</p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法，是在调用方法的时候指明泛型的具体类型 。<br>如上面代码中，remove、add函数就是使用了泛型的泛型方法。</p><p>需要注意的是，当方法是静态方法时，必须将静态方法也定义成泛型方法<br><img src="https://img-blog.csdnimg.cn/20201028120939864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型还会使用在接口上，</p><pre><code class="hljs java"><span class="hljs-comment">//定义一个泛型接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h1 id="四、泛型的特性"><a href="#四、泛型的特性" class="headerlink" title="四、泛型的特性"></a>四、泛型的特性</h1><p>泛型的一大特性为：只在编译阶段有效<br>如下面一个例子：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericsErasureTypeDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;Object&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();        List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();        System.out.println(list1.getClass());        System.out.println(list2.getClass());    &#125;&#125;<span class="hljs-comment">// Output:</span><span class="hljs-comment">// class java.util.ArrayList</span><span class="hljs-comment">// class java.util.ArrayList</span></code></pre><p>在编译过程中，泛型的具体实例化类型只会在编译过程中被用于判断是否类型匹配，但是在编译结束后，程序会采取去泛型化的措施。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。因此，在运行时，list1和list2均为List类型。<br>在编译擦除过程中，具体进行了以下操作：<br>（1）把泛型中的所有类型参数替换为 Object，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。<br>（2）擦除出现的类型声明，即去掉 &lt;&gt; 的内容。比如 T get() 方法声明就变成了 Object get() ；List<String> 就变成了 List。如有必要，插入类型转换以保持类型安全。<br>（3）生成桥接方法以保留扩展泛型类型中的多态性。类型擦除确保不为参数化类型创建新类；因此，泛型不会产生运行时开销。</p><h1 id="五、泛型的通配符"><a href="#五、泛型的通配符" class="headerlink" title="五、泛型的通配符"></a>五、泛型的通配符</h1><h2 id="（一）一般通配符"><a href="#（一）一般通配符" class="headerlink" title="（一）一般通配符"></a>（一）一般通配符</h2><p>1.泛型通配符</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericsErasureTypeDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;Object&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();        List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showFirstValue1</span><span class="hljs-params">(List&lt;String&gt; obj)</span></span>&#123;    Log.d(<span class="hljs-string">&quot;泛型测试&quot;</span>,<span class="hljs-string">&quot;the first value is &quot;</span> + obj.getfirst());&#125;    &#125;&#125;</code></pre><p>在这种情况下，显然list1是不可以调用showFirstValue1函数的，而list2可以，尽管他们在实际运行时是同一个类型（参照泛型的特征）。此时，若是想让showFirstValue1函数可以被两个对象调用可以使用通配符。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showFirstValue1</span><span class="hljs-params">(List&lt;?&gt; obj)</span></span>&#123;    Log.d(<span class="hljs-string">&quot;泛型测试&quot;</span>,<span class="hljs-string">&quot;the first value is &quot;</span> + obj.getFirst());    &#125;</code></pre><p>类型通配符一般是使用？代替具体的类型实参，<strong>注意了，此处’？’是类型实参，而不是类型形参 。</strong>再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</p><h2 id="（二）有上下界的通配符"><a href="#（二）有上下界的通配符" class="headerlink" title="（二）有上下界的通配符"></a>（二）有上下界的通配符</h2><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。<br>1.上界（上：子类，下：父类）<br>为泛型添加上边界，即传入的类型实参必须是指定类型的子类型。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showFirstValue1</span><span class="hljs-params">(List&lt;? extends String&gt; obj)</span></span>&#123;    Log.d(<span class="hljs-string">&quot;泛型测试&quot;</span>,<span class="hljs-string">&quot;first value is &quot;</span> + obj.getFirst());&#125;</code></pre><p>2.下界<br>下界用 super 关键字声明，表示参数化的类型可能是所指定的类型或者其任意父类。泛型的下界就是 B 类。<br>形如 List&lt;? super B&gt;</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showFirstValue1</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> object&gt; obj)</span></span>&#123;    Log.d(<span class="hljs-string">&quot;泛型测试&quot;</span>,<span class="hljs-string">&quot;first value is &quot;</span> + obj.getFirst());&#125;</code></pre><h1 id="六、泛型的注意事项"><a href="#六、泛型的注意事项" class="headerlink" title="六、泛型的注意事项"></a>六、泛型的注意事项</h1><p>1.不能创建类型参数的实例</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(List&lt;E&gt; list)</span> </span>&#123;    E elem = <span class="hljs-keyword">new</span> E();  <span class="hljs-comment">// 编译错误</span>    list.add(elem);&#125;</code></pre><p>2.不能声明类型为类型参数的静态成员</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileDevice</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> T os; <span class="hljs-comment">// error</span>    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>3.类型参数不能使用类型转换或 instanceof</p><pre><code class="hljs java">List&lt;Integer&gt; li = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();List&lt;Number&gt;  ln = (List&lt;Number&gt;) li;  <span class="hljs-comment">// 编译错误</span></code></pre><p>4.不能创建类型参数的数组<br>数组必须明确知道内部元素的类型，而且编译器会”记住“这个类型，每次往数组里插入新元素都会进行类型检查，不匹配会抛出java.lang.ArrayStoreException错误。<br>而泛型类型擦除，在运行时JVM是不知道泛型信息的，因此array0fLists中可以存储任意类型的数据，这显然是不可以的。）</p><pre><code class="hljs java">List&lt;Integer&gt;[] arrayOfLists = <span class="hljs-keyword">new</span> List&lt;Integer&gt;[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 编译错误</span></code></pre><p>但是使用通配符是可以的（通配符的方式，最后取出数据是要做显式的类型转换的）</p><pre><code class="hljs java">List&lt;?&gt;[] arrayOfLists = <span class="hljs-keyword">new</span> List&lt;?&gt;[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 编译正确</span></code></pre><p>这样也可以：</p><pre><code class="hljs java">List&lt;?&gt;[] arrayOfLists = <span class="hljs-keyword">new</span> List[<span class="hljs-number">2</span>];</code></pre><p>5.不能创建、catch 或 throw 参数化类型对象</p><pre><code class="hljs java"><span class="hljs-comment">// Extends Throwable indirectly</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MathException</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;    <span class="hljs-comment">// 编译错误</span><span class="hljs-comment">// Extends Throwable directly</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueFullException</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Throwable</span> </span>&#123; <span class="hljs-comment">/* ... */</span> <span class="hljs-comment">// 编译错误</span></code></pre><p>6.仅仅是泛型类相同，而类型参数不同的方法不能重载</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Set&lt;String&gt; strSet)</span> </span>&#123; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Set&lt;Integer&gt; intSet)</span> </span>&#123; &#125; <span class="hljs-comment">// 编译错误</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java知识点总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-JAVA -基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String、StringBuilder、StringBuffer的区别</title>
    <link href="/2020/10/String%E3%80%81StringBuilder%E3%80%81StringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/10/String%E3%80%81StringBuilder%E3%80%81StringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="一、String类型"><a href="#一、String类型" class="headerlink" title="一、String类型"></a>一、String类型</h1><p>String类型在Java中是十分常用的类型，指向一个字符串，如：“ABC”、“123”等。String类是定义于java.lang.string包中的，该包提供了切割、复制、查找等函数。String是一个用 final 声明的常量类，不能被任何类所继承，且无法被修改。</p><h2 id="（一）String不变性"><a href="#（一）String不变性" class="headerlink" title="（一）String不变性"></a>（一）String不变性</h2><p> 关于String类，一个重要的特性是其不可变性，即一个字符串一旦被创建，就不会再被修改。但是显然我们在写代码时，以下句子是可以被通过的：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">String s</span> = <span class="hljs-string">&quot;abcd&quot;</span>;<span class="hljs-attribute">s</span> = <span class="hljs-string">&quot;123&quot;</span>;</code></pre><p>这是因为，这种不可变性指的是其内存中的实现。当我们创建一个字符串时，内存中会创建这样的一个字符串对象的引用。而当我们尝试修改s的内容时，我们并不是修改字符串对象，而是在内存中重新创建了一个字符串对象，并且将指针指向了这个新创建的字符串对象。<br><img src="https://img-blog.csdnimg.cn/20201026110232932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="（二）String在内存中的两种存储方法"><a href="#（二）String在内存中的两种存储方法" class="headerlink" title="（二）String在内存中的两种存储方法"></a>（二）String在内存中的两种存储方法</h2><h3 id="1-存储位置"><a href="#1-存储位置" class="headerlink" title="1.存储位置"></a>1.存储位置</h3><p>String实际上是一个指针（原型为一个char*类型的指针，学过C/C++应该明白），而这个指针存储的位置可以是栈或者堆，这主要是取决于这个字符串被创建的方法，自动创建的变量是存在栈中的，而通过new生成的变量是存储在堆中的。</p><p> 创建方法一：</p><pre><code class="hljs abnf">String str1 = <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-comment">; </span></code></pre><p>步骤： </p><ol><li>栈中开辟一块空间存放引用str1， </li><li>String池中开辟一块空间，存放String常量”abc”， </li><li>引用str1指向池中String常量”abc”， </li><li>str1所指代的地址即常量”abc”所在地址，输出为true </li></ol><p>创建方法二：</p><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> str2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);</code></pre><p>步骤： </p><ol><li>栈中开辟一块空间存放引用str2， </li><li>堆中开辟一块空间存放一个新建的String对象”abc”， </li><li>引用str2指向堆中的新建的String对象”abc”， </li><li>str2所指代的对象地址为堆中地址，而常量”abc”地址在池中，输出为false </li></ol><p>注意：第一种创建方法得到的字符串常量存储在常量池中，而且具有不变性，而第二种创建方法则存储在堆中，不具有不变性（相同字符串也是存储在不同地址的）。</p><h3 id="2-存储方式——字符串常量池"><a href="#2-存储方式——字符串常量池" class="headerlink" title="2. 存储方式——字符串常量池"></a>2. 存储方式——字符串常量池</h3><p>在Java的内存分配中，总共3种常量池，分别是Class常量池、运行时常量池、字符串常量池，String类型的对象自然是存在字符串常量池中。</p><p>字符串的分配需要消耗高昂的时间和空间的，而且字符串使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性，常量池中一定不存在两个相同的字符串。</p><p>所以说，如果两个字符串指针指向了同一个字符串，如：</p><pre><code class="hljs abnf">String s = <span class="hljs-string">&quot;abcd&quot;</span><span class="hljs-comment">;</span>String s2 = <span class="hljs-string">&quot;abcd&quot;</span><span class="hljs-comment">;</span></code></pre><p>则会指向字符串常量池中的同一个字符串对象。<br><img src="https://img-blog.csdnimg.cn/20201026113357606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>当String类对字符串进行连接操作时，同样的，也是在字符串常量池中创建了一个新的字符串，并将字符串指针指向了该字符串。</p><pre><code class="hljs ini"><span class="hljs-attr">s</span> = s.concat(<span class="hljs-string">&quot;ef&quot;</span>)<span class="hljs-comment">;</span></code></pre><p><img src="https://img-blog.csdnimg.cn/20201026120412178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="（三）java-lang-String提供的函数"><a href="#（三）java-lang-String提供的函数" class="headerlink" title="（三）java.lang.String提供的函数"></a>（三）java.lang.String提供的函数</h2><p>1    char charAt(int index)<br>返回指定索引处的 char 值。<br>2    int compareTo(Object o)<br>把这个字符串和另一个对象比较。<br>3    int compareTo(String anotherString)<br>按字典顺序比较两个字符串。<br>4    int compareToIgnoreCase(String str)<br>按字典顺序比较两个字符串，不考虑大小写。<br>5    String concat(String str)<br>将指定字符串连接到此字符串的结尾。<br>6    boolean contentEquals(StringBuffer sb)<br>当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。<br>7    static String copyValueOf(char[] data)<br>返回指定数组中表示该字符序列的 String。<br>8    static String copyValueOf(char[] data, int offset, int count)<br>返回指定数组中表示该字符序列的 String。<br>9    boolean endsWith(String suffix)<br>测试此字符串是否以指定的后缀结束。<br>10    boolean equals(Object anObject)<br>将此字符串与指定的对象比较。<br>11    boolean equalsIgnoreCase(String anotherString)<br>将此 String 与另一个 String 比较，不考虑大小写。<br>12    byte[] getBytes()<br> 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。<br>13    byte[] getBytes(String charsetName)<br>使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。<br>14    void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)<br>将字符从此字符串复制到目标字符数组。<br>15    int hashCode()<br>返回此字符串的哈希码。<br>16    int indexOf(int ch)<br>返回指定字符在此字符串中第一次出现处的索引。<br>17    int indexOf(int ch, int fromIndex)<br>返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。<br>18    int indexOf(String str)<br> 返回指定子字符串在此字符串中第一次出现处的索引。<br>19    int indexOf(String str, int fromIndex)<br>返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。<br>20    String intern()<br> 返回字符串对象的规范化表示形式。<br>21    int lastIndexOf(int ch)<br> 返回指定字符在此字符串中最后一次出现处的索引。<br>22    int lastIndexOf(int ch, int fromIndex)<br>返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。<br>23    int lastIndexOf(String str)<br>返回指定子字符串在此字符串中最右边出现处的索引。<br>24    int lastIndexOf(String str, int fromIndex)<br> 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。<br>25    int length()<br>返回此字符串的长度。<br>26    boolean matches(String regex)<br>告知此字符串是否匹配给定的正则表达式。<br>27    boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)<br>测试两个字符串区域是否相等。<br>28    boolean regionMatches(int toffset, String other, int ooffset, int len)<br>测试两个字符串区域是否相等。<br>29    String replace(char oldChar, char newChar)<br>返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。<br>30    String replaceAll(String regex, String replacement)<br>使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。<br>31    String replaceFirst(String regex, String replacement)<br> 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。<br>32    String[] split(String regex)<br>根据给定正则表达式的匹配拆分此字符串。<br>33    String[] split(String regex, int limit)<br>根据匹配给定的正则表达式来拆分此字符串。<br>34    boolean startsWith(String prefix)<br>测试此字符串是否以指定的前缀开始。<br>35    boolean startsWith(String prefix, int toffset)<br>测试此字符串从指定索引开始的子字符串是否以指定前缀开始。<br>36    CharSequence subSequence(int beginIndex, int endIndex)<br> 返回一个新的字符序列，它是此序列的一个子序列。<br>37    String substring(int beginIndex)<br>返回一个新的字符串，它是此字符串的一个子字符串。<br>38    String substring(int beginIndex, int endIndex)<br>返回一个新字符串，它是此字符串的一个子字符串。<br>39    char[] toCharArray()<br>将此字符串转换为一个新的字符数组。<br>40    String toLowerCase()<br>使用默认语言环境的规则将此 String 中的所有字符都转换为小写。<br>41    String toLowerCase(Locale locale)<br> 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。<br>42    String toString()<br> 返回此对象本身（它已经是一个字符串！）。<br>43    String toUpperCase()<br>使用默认语言环境的规则将此 String 中的所有字符都转换为大写。<br>44    String toUpperCase(Locale locale)<br>使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。<br>45    String trim()<br>返回字符串的副本，忽略前导空白和尾部空白。<br>46    static String valueOf(primitive data type x)<br>返回给定data type类型x参数的字符串表示形式。<br>47    contains(CharSequence chars)<br>判断是否包含指定的字符系列。<br>48    isEmpty()<br>判断字符串是否为空。</p><h1 id="二、StringBuilder"><a href="#二、StringBuilder" class="headerlink" title="二、StringBuilder"></a>二、StringBuilder</h1><p>StringBuffer类也代表字符串, 内部实现跟String不一样。</p><h2 id="（一）StringBuilder的存储方法"><a href="#（一）StringBuilder的存储方法" class="headerlink" title="（一）StringBuilder的存储方法"></a>（一）StringBuilder的存储方法</h2><p>StringBuilder的继承结构如下：<br><img src="https://img-blog.csdnimg.cn/20201026121521701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>StringBuilder对象则代表一个字符序列可变的字符串，StringBuilder内部维护了一个char[]类型的value，当我们要修改指向的字符串时可通过StringBuilder提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列，而非创建一个新的String对象。一旦通过StringBuilder生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。这种存储方式使得存储的字符串更少，因此拥有更高的效率和更少的存储空间。当我们想要连接两个字符串时进行的操作如下图：<br><img src="https://img-blog.csdnimg.cn/20201026121809565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在StringBuilder中如果数组的剩余容量，无法添加全部内容，则通过expandCapacity(int minimumCapacity)方法对value进行扩容，其中minimumCapacity = 原value长度 + append添加的内容长度。<br>1、扩大容量为原来的两倍 + 2，为什么要 + 2，而不是刚好两倍？<br>2、如果扩容之后，还是无法添加全部内容，则将 minimumCapacity 作为最终的容量大小；<br>3、利用 System.arraycopy 方法对原value数据进行复制；<br>在使用StringBuilder时，如果给定一个合适的初始值，可以避免由于char[]数组多次复制而导致的性能问题。</p><h2 id="（二）java-lag-StrigBuilder提供的函数"><a href="#（二）java-lag-StrigBuilder提供的函数" class="headerlink" title="（二）java.lag.StrigBuilder提供的函数"></a>（二）java.lag.StrigBuilder提供的函数</h2><p>一、创建Stringbuilder对象<br>StringBuilder strB = new StringBuilder();</p><p>1 append(String str)/append(Char c)<br>字符串连接<br>2 toString()<br>返回一个与构建起或缓冲器内容相同的字符串<br>3 appendcodePoint(int cp)<br>追加一个代码点，并将其转换为一个或两个代码单元并返回this<br>4 setCharAt(int i, char c)<br>将第 i 个代码单元设置为 c（可以理解为替换）char字符使用  ‘   ’<br>5 insert(int offset, String str)/insert(int offset, Char c)<br>在指定位置之前插入字符(串)<br>6 delete(int startIndex,int endIndex)<br>删除起始位置（含）到结尾位置（不含）之间的字符串</p><h1 id="三、StringBuffer"><a href="#三、StringBuffer" class="headerlink" title="三、StringBuffer"></a>三、StringBuffer</h1><p>StringBuffer和StringBuilder类似，提供了几乎同样的函数，不同的是：StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。</p><p>线程安全的实现是通过synchronized实现的，StringBuffer类中的方法都添加了synchronized关键字，也就是给这个方法添加了一个锁，用来保证线程安全。<br><img src="https://img-blog.csdnimg.cn/2020102612315195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>但是线程安全的实现必然会带来时间性能上的减弱。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Sting、StringBuilder、StringBuffer三者均用于实现字符串，但由于其字符串存储方法的不同，三者时间性能上从优到差为StringBuilder&gt;StringBuffer&gt;String。所以：<br>（1）如果要操作少量的数据用 String；<br>（2）多线程操作字符串缓冲区下操作大量数据 StringBuffer；<br>（3）单线程操作字符串缓冲区下操作大量数据 StringBuilder。</p>]]></content>
    
    
    <categories>
      
      <category>Java知识点总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-JAVA -基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
