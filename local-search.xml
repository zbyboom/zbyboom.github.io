<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java 如何理解泛型</title>
    <link href="/2020/10/Java%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B/"/>
    <url>/2020/10/Java%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一、什么是泛型"><a href="#一、什么是泛型" class="headerlink" title="一、什么是泛型"></a>一、什么是泛型</h1><p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><p>如下面一段代码中，<String>部分就是一个泛型的应用，类型String被像参数一样传递了。</p><pre><code class="hljs java">List&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();</code></pre><h1 id="二、为什么要用泛型"><a href="#二、为什么要用泛型" class="headerlink" title="二、为什么要用泛型"></a>二、为什么要用泛型</h1><p>早期Java是使用Object来代表任意类型的，但是向下转型有强转的问题，这样程序就不太安全<br>（强转：子类到父类可以很自然的转化，但是父类到子类就必须通过强制类型转化。）</p><p>首先，我们来试想一下：没有泛型，集合会怎么样<br>强转是非常危险的：Collection、Map集合对元素的类型是没有任何限制的。本来我的Collection集合装载的是全部的Dog对象，但是外边把Cat对象存储到集合中，是没有任何语法错误的（因为Dog和Cat均为其子类）。</p><p>把对象扔进集合中，集合是不知道元素的类型是什么的，仅仅知道是Object。因此在get()的时候，返回的是Object。外边获取该对象，还需要强制转换。</p><p>而使用泛型后，返回的值就只能被强转为某一特定类型，就不会出现上述问题了。</p><p>所以泛型的优点有：<br>1.代码更加简洁【不用强制转换】<br>2.程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】<br>3.可读性和稳定性【在编写集合的时候，就限定了类型】</p><h1 id="三、如何使用泛型"><a href="#三、如何使用泛型" class="headerlink" title="三、如何使用泛型"></a>三、如何使用泛型</h1><h2 id="（一）泛型的语法"><a href="#（一）泛型的语法" class="headerlink" title="（一）泛型的语法"></a>（一）泛型的语法</h2><p>泛型类的语法形式：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">name</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>, ..., <span class="hljs-title">Tn</span>&gt; </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;</code></pre><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。由尖括号（&lt;&gt;）分隔的类型参数部分跟在类名后面。它指定类型参数（也称为类型变量）T1，T2，…和 Tn。在实际应用中T1…Tn常使用T、E、V。如下面代码，该代码是基于泛型定义一个链表。</p><pre><code class="hljs java"><span class="hljs-comment">/*1.泛型类*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>&lt;<span class="hljs-title">E</span>&gt;</span>&#123;    <span class="hljs-keyword">public</span> E data;    <span class="hljs-keyword">public</span> ListNode next;    <span class="hljs-keyword">public</span> ListNode previous;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListNode</span> <span class="hljs-params">(E d)</span></span>&#123;        <span class="hljs-keyword">this</span>.data = d;        <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">this</span>.previous = <span class="hljs-keyword">null</span>;    &#125;&#125;<span class="hljs-comment">//链表</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    <span class="hljs-keyword">public</span> ListNode first;    <span class="hljs-keyword">public</span> ListNode last;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> size;    <span class="hljs-comment">//初始化函数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">()</span></span>&#123;        first=last=<span class="hljs-keyword">null</span>;        size = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//添加一个节点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E num)</span></span>&#123;        ListNode node = <span class="hljs-keyword">new</span> ListNode(num);        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)&#123;            node.next = <span class="hljs-keyword">null</span>;            node.previous = <span class="hljs-keyword">null</span>;            first =  last = node;            size = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span>&#123;            last.next = node;            node.previous = last;            last = node;            size ++;        &#125;    &#125;    <span class="hljs-comment">//移除一个节点</span>    <span class="hljs-comment">/*2.泛型方法*/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(E num)</span></span>&#123;        ListNode cur = first;        <span class="hljs-keyword">while</span>(cur.data != num)&#123;            cur=cur.next;        &#125;        <span class="hljs-comment">//当前结点就是要移除的节点</span>        cur.previous.next = cur.next;        cur.next.previous = cur.previous;        <span class="hljs-keyword">return</span> (E) cur.data;<span class="hljs-comment">//强制类型转化</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;        ListNode cur = first;        <span class="hljs-keyword">while</span>(cur != last)&#123;            System.out.println(cur.data);            cur = cur.next;        &#125;        System.out.println(cur.data);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList();        ll.add(<span class="hljs-number">1</span>);        ll.add(<span class="hljs-number">2</span>);        ll.add(<span class="hljs-number">3</span>);        ll.show();        ll.remove(<span class="hljs-number">2</span>);        ll.show();    &#125;&#125;</code></pre><p>在泛型的&lt;&gt;中，使用的是引用类型而非常见的基本类型，二者的对应如下：<br><img src="https://img-blog.csdnimg.cn/20201027162257644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="（二）泛型的使用"><a href="#（二）泛型的使用" class="headerlink" title="（二）泛型的使用"></a>（二）泛型的使用</h2><p>泛型常用于泛型类、泛型方法、泛型接口三种情况。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。<br>如上面的代码中，ListNode、LinkedList就是使用了泛型的泛型类。</p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法，是在调用方法的时候指明泛型的具体类型 。<br>如上面代码中，remove、add函数就是使用了泛型的泛型方法。</p><p>需要注意的是，当方法是静态方法时，必须将静态方法也定义成泛型方法<br><img src="https://img-blog.csdnimg.cn/20201028120939864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型还会使用在接口上，</p><pre><code class="hljs java"><span class="hljs-comment">//定义一个泛型接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h1 id="四、泛型的特性"><a href="#四、泛型的特性" class="headerlink" title="四、泛型的特性"></a>四、泛型的特性</h1><p>泛型的一大特性为：只在编译阶段有效<br>如下面一个例子：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericsErasureTypeDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;Object&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();        List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();        System.out.println(list1.getClass());        System.out.println(list2.getClass());    &#125;&#125;<span class="hljs-comment">// Output:</span><span class="hljs-comment">// class java.util.ArrayList</span><span class="hljs-comment">// class java.util.ArrayList</span></code></pre><p>在编译过程中，泛型的具体实例化类型只会在编译过程中被用于判断是否类型匹配，但是在编译结束后，程序会采取去泛型化的措施。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。因此，在运行时，list1和list2均为List类型。<br>在编译擦除过程中，具体进行了以下操作：<br>（1）把泛型中的所有类型参数替换为 Object，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。<br>（2）擦除出现的类型声明，即去掉 &lt;&gt; 的内容。比如 T get() 方法声明就变成了 Object get() ；List<String> 就变成了 List。如有必要，插入类型转换以保持类型安全。<br>（3）生成桥接方法以保留扩展泛型类型中的多态性。类型擦除确保不为参数化类型创建新类；因此，泛型不会产生运行时开销。</p><h1 id="五、泛型的通配符"><a href="#五、泛型的通配符" class="headerlink" title="五、泛型的通配符"></a>五、泛型的通配符</h1><h2 id="（一）一般通配符"><a href="#（一）一般通配符" class="headerlink" title="（一）一般通配符"></a>（一）一般通配符</h2><p>1.泛型通配符</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericsErasureTypeDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;Object&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();        List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showFirstValue1</span><span class="hljs-params">(List&lt;String&gt; obj)</span></span>&#123;    Log.d(<span class="hljs-string">&quot;泛型测试&quot;</span>,<span class="hljs-string">&quot;the first value is &quot;</span> + obj.getfirst());&#125;    &#125;&#125;</code></pre><p>在这种情况下，显然list1是不可以调用showFirstValue1函数的，而list2可以，尽管他们在实际运行时是同一个类型（参照泛型的特征）。此时，若是想让showFirstValue1函数可以被两个对象调用可以使用通配符。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showFirstValue1</span><span class="hljs-params">(List&lt;?&gt; obj)</span></span>&#123;    Log.d(<span class="hljs-string">&quot;泛型测试&quot;</span>,<span class="hljs-string">&quot;the first value is &quot;</span> + obj.getFirst());    &#125;</code></pre><p>类型通配符一般是使用？代替具体的类型实参，<strong>注意了，此处’？’是类型实参，而不是类型形参 。</strong>再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</p><h2 id="（二）有上下界的通配符"><a href="#（二）有上下界的通配符" class="headerlink" title="（二）有上下界的通配符"></a>（二）有上下界的通配符</h2><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。<br>1.上界（上：子类，下：父类）<br>为泛型添加上边界，即传入的类型实参必须是指定类型的子类型。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showFirstValue1</span><span class="hljs-params">(List&lt;? extends String&gt; obj)</span></span>&#123;    Log.d(<span class="hljs-string">&quot;泛型测试&quot;</span>,<span class="hljs-string">&quot;first value is &quot;</span> + obj.getFirst());&#125;</code></pre><p>2.下界<br>下界用 super 关键字声明，表示参数化的类型可能是所指定的类型或者其任意父类。泛型的下界就是 B 类。<br>形如 List&lt;? super B&gt;</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showFirstValue1</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> object&gt; obj)</span></span>&#123;    Log.d(<span class="hljs-string">&quot;泛型测试&quot;</span>,<span class="hljs-string">&quot;first value is &quot;</span> + obj.getFirst());&#125;</code></pre><h1 id="六、泛型的注意事项"><a href="#六、泛型的注意事项" class="headerlink" title="六、泛型的注意事项"></a>六、泛型的注意事项</h1><p>1.不能创建类型参数的实例</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(List&lt;E&gt; list)</span> </span>&#123;    E elem = <span class="hljs-keyword">new</span> E();  <span class="hljs-comment">// 编译错误</span>    list.add(elem);&#125;</code></pre><p>2.不能声明类型为类型参数的静态成员</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileDevice</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> T os; <span class="hljs-comment">// error</span>    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>3.类型参数不能使用类型转换或 instanceof</p><pre><code class="hljs java">List&lt;Integer&gt; li = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();List&lt;Number&gt;  ln = (List&lt;Number&gt;) li;  <span class="hljs-comment">// 编译错误</span></code></pre><p>4.不能创建类型参数的数组<br>数组必须明确知道内部元素的类型，而且编译器会”记住“这个类型，每次往数组里插入新元素都会进行类型检查，不匹配会抛出java.lang.ArrayStoreException错误。<br>而泛型类型擦除，在运行时JVM是不知道泛型信息的，因此array0fLists中可以存储任意类型的数据，这显然是不可以的。）</p><pre><code class="hljs java">List&lt;Integer&gt;[] arrayOfLists = <span class="hljs-keyword">new</span> List&lt;Integer&gt;[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 编译错误</span></code></pre><p>但是使用通配符是可以的（通配符的方式，最后取出数据是要做显式的类型转换的）</p><pre><code class="hljs java">List&lt;?&gt;[] arrayOfLists = <span class="hljs-keyword">new</span> List&lt;?&gt;[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 编译正确</span></code></pre><p>这样也可以：</p><pre><code class="hljs java">List&lt;?&gt;[] arrayOfLists = <span class="hljs-keyword">new</span> List[<span class="hljs-number">2</span>];</code></pre><p>5.不能创建、catch 或 throw 参数化类型对象</p><pre><code class="hljs java"><span class="hljs-comment">// Extends Throwable indirectly</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MathException</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;    <span class="hljs-comment">// 编译错误</span><span class="hljs-comment">// Extends Throwable directly</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueFullException</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Throwable</span> </span>&#123; <span class="hljs-comment">/* ... */</span> <span class="hljs-comment">// 编译错误</span></code></pre><p>6.仅仅是泛型类相同，而类型参数不同的方法不能重载</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Set&lt;String&gt; strSet)</span> </span>&#123; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Set&lt;Integer&gt; intSet)</span> </span>&#123; &#125; <span class="hljs-comment">// 编译错误</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java知识点总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-JAVA -基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String、StringBuilder、StringBuffer的区别</title>
    <link href="/2020/10/String%E3%80%81StringBuilder%E3%80%81StringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/10/String%E3%80%81StringBuilder%E3%80%81StringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="一、String类型"><a href="#一、String类型" class="headerlink" title="一、String类型"></a>一、String类型</h1><p>String类型在Java中是十分常用的类型，指向一个字符串，如：“ABC”、“123”等。String类是定义于java.lang.string包中的，该包提供了切割、复制、查找等函数。String是一个用 final 声明的常量类，不能被任何类所继承，且无法被修改。</p><h2 id="（一）String不变性"><a href="#（一）String不变性" class="headerlink" title="（一）String不变性"></a>（一）String不变性</h2><p> 关于String类，一个重要的特性是其不可变性，即一个字符串一旦被创建，就不会再被修改。但是显然我们在写代码时，以下句子是可以被通过的：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">String s</span> = <span class="hljs-string">&quot;abcd&quot;</span>;<span class="hljs-attribute">s</span> = <span class="hljs-string">&quot;123&quot;</span>;</code></pre><p>这是因为，这种不可变性指的是其内存中的实现。当我们创建一个字符串时，内存中会创建这样的一个字符串对象的引用。而当我们尝试修改s的内容时，我们并不是修改字符串对象，而是在内存中重新创建了一个字符串对象，并且将指针指向了这个新创建的字符串对象。<br><img src="https://img-blog.csdnimg.cn/20201026110232932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="（二）String在内存中的两种存储方法"><a href="#（二）String在内存中的两种存储方法" class="headerlink" title="（二）String在内存中的两种存储方法"></a>（二）String在内存中的两种存储方法</h2><h3 id="1-存储位置"><a href="#1-存储位置" class="headerlink" title="1.存储位置"></a>1.存储位置</h3><p>String实际上是一个指针（原型为一个char*类型的指针，学过C/C++应该明白），而这个指针存储的位置可以是栈或者堆，这主要是取决于这个字符串被创建的方法，自动创建的变量是存在栈中的，而通过new生成的变量是存储在堆中的。</p><p> 创建方法一：</p><pre><code class="hljs abnf">String str1 = <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-comment">; </span></code></pre><p>步骤： </p><ol><li>栈中开辟一块空间存放引用str1， </li><li>String池中开辟一块空间，存放String常量”abc”， </li><li>引用str1指向池中String常量”abc”， </li><li>str1所指代的地址即常量”abc”所在地址，输出为true </li></ol><p>创建方法二：</p><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> str2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);</code></pre><p>步骤： </p><ol><li>栈中开辟一块空间存放引用str2， </li><li>堆中开辟一块空间存放一个新建的String对象”abc”， </li><li>引用str2指向堆中的新建的String对象”abc”， </li><li>str2所指代的对象地址为堆中地址，而常量”abc”地址在池中，输出为false </li></ol><p>注意：第一种创建方法得到的字符串常量存储在常量池中，而且具有不变性，而第二种创建方法则存储在堆中，不具有不变性（相同字符串也是存储在不同地址的）。</p><h3 id="2-存储方式——字符串常量池"><a href="#2-存储方式——字符串常量池" class="headerlink" title="2. 存储方式——字符串常量池"></a>2. 存储方式——字符串常量池</h3><p>在Java的内存分配中，总共3种常量池，分别是Class常量池、运行时常量池、字符串常量池，String类型的对象自然是存在字符串常量池中。</p><p>字符串的分配需要消耗高昂的时间和空间的，而且字符串使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性，常量池中一定不存在两个相同的字符串。</p><p>所以说，如果两个字符串指针指向了同一个字符串，如：</p><pre><code class="hljs abnf">String s = <span class="hljs-string">&quot;abcd&quot;</span><span class="hljs-comment">;</span>String s2 = <span class="hljs-string">&quot;abcd&quot;</span><span class="hljs-comment">;</span></code></pre><p>则会指向字符串常量池中的同一个字符串对象。<br><img src="https://img-blog.csdnimg.cn/20201026113357606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>当String类对字符串进行连接操作时，同样的，也是在字符串常量池中创建了一个新的字符串，并将字符串指针指向了该字符串。</p><pre><code class="hljs ini"><span class="hljs-attr">s</span> = s.concat(<span class="hljs-string">&quot;ef&quot;</span>)<span class="hljs-comment">;</span></code></pre><p><img src="https://img-blog.csdnimg.cn/20201026120412178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="（三）java-lang-String提供的函数"><a href="#（三）java-lang-String提供的函数" class="headerlink" title="（三）java.lang.String提供的函数"></a>（三）java.lang.String提供的函数</h2><p>1    char charAt(int index)<br>返回指定索引处的 char 值。<br>2    int compareTo(Object o)<br>把这个字符串和另一个对象比较。<br>3    int compareTo(String anotherString)<br>按字典顺序比较两个字符串。<br>4    int compareToIgnoreCase(String str)<br>按字典顺序比较两个字符串，不考虑大小写。<br>5    String concat(String str)<br>将指定字符串连接到此字符串的结尾。<br>6    boolean contentEquals(StringBuffer sb)<br>当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。<br>7    static String copyValueOf(char[] data)<br>返回指定数组中表示该字符序列的 String。<br>8    static String copyValueOf(char[] data, int offset, int count)<br>返回指定数组中表示该字符序列的 String。<br>9    boolean endsWith(String suffix)<br>测试此字符串是否以指定的后缀结束。<br>10    boolean equals(Object anObject)<br>将此字符串与指定的对象比较。<br>11    boolean equalsIgnoreCase(String anotherString)<br>将此 String 与另一个 String 比较，不考虑大小写。<br>12    byte[] getBytes()<br> 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。<br>13    byte[] getBytes(String charsetName)<br>使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。<br>14    void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)<br>将字符从此字符串复制到目标字符数组。<br>15    int hashCode()<br>返回此字符串的哈希码。<br>16    int indexOf(int ch)<br>返回指定字符在此字符串中第一次出现处的索引。<br>17    int indexOf(int ch, int fromIndex)<br>返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。<br>18    int indexOf(String str)<br> 返回指定子字符串在此字符串中第一次出现处的索引。<br>19    int indexOf(String str, int fromIndex)<br>返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。<br>20    String intern()<br> 返回字符串对象的规范化表示形式。<br>21    int lastIndexOf(int ch)<br> 返回指定字符在此字符串中最后一次出现处的索引。<br>22    int lastIndexOf(int ch, int fromIndex)<br>返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。<br>23    int lastIndexOf(String str)<br>返回指定子字符串在此字符串中最右边出现处的索引。<br>24    int lastIndexOf(String str, int fromIndex)<br> 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。<br>25    int length()<br>返回此字符串的长度。<br>26    boolean matches(String regex)<br>告知此字符串是否匹配给定的正则表达式。<br>27    boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)<br>测试两个字符串区域是否相等。<br>28    boolean regionMatches(int toffset, String other, int ooffset, int len)<br>测试两个字符串区域是否相等。<br>29    String replace(char oldChar, char newChar)<br>返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。<br>30    String replaceAll(String regex, String replacement)<br>使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。<br>31    String replaceFirst(String regex, String replacement)<br> 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。<br>32    String[] split(String regex)<br>根据给定正则表达式的匹配拆分此字符串。<br>33    String[] split(String regex, int limit)<br>根据匹配给定的正则表达式来拆分此字符串。<br>34    boolean startsWith(String prefix)<br>测试此字符串是否以指定的前缀开始。<br>35    boolean startsWith(String prefix, int toffset)<br>测试此字符串从指定索引开始的子字符串是否以指定前缀开始。<br>36    CharSequence subSequence(int beginIndex, int endIndex)<br> 返回一个新的字符序列，它是此序列的一个子序列。<br>37    String substring(int beginIndex)<br>返回一个新的字符串，它是此字符串的一个子字符串。<br>38    String substring(int beginIndex, int endIndex)<br>返回一个新字符串，它是此字符串的一个子字符串。<br>39    char[] toCharArray()<br>将此字符串转换为一个新的字符数组。<br>40    String toLowerCase()<br>使用默认语言环境的规则将此 String 中的所有字符都转换为小写。<br>41    String toLowerCase(Locale locale)<br> 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。<br>42    String toString()<br> 返回此对象本身（它已经是一个字符串！）。<br>43    String toUpperCase()<br>使用默认语言环境的规则将此 String 中的所有字符都转换为大写。<br>44    String toUpperCase(Locale locale)<br>使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。<br>45    String trim()<br>返回字符串的副本，忽略前导空白和尾部空白。<br>46    static String valueOf(primitive data type x)<br>返回给定data type类型x参数的字符串表示形式。<br>47    contains(CharSequence chars)<br>判断是否包含指定的字符系列。<br>48    isEmpty()<br>判断字符串是否为空。</p><h1 id="二、StringBuilder"><a href="#二、StringBuilder" class="headerlink" title="二、StringBuilder"></a>二、StringBuilder</h1><p>StringBuffer类也代表字符串, 内部实现跟String不一样。</p><h2 id="（一）StringBuilder的存储方法"><a href="#（一）StringBuilder的存储方法" class="headerlink" title="（一）StringBuilder的存储方法"></a>（一）StringBuilder的存储方法</h2><p>StringBuilder的继承结构如下：<br><img src="https://img-blog.csdnimg.cn/20201026121521701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>StringBuilder对象则代表一个字符序列可变的字符串，StringBuilder内部维护了一个char[]类型的value，当我们要修改指向的字符串时可通过StringBuilder提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列，而非创建一个新的String对象。一旦通过StringBuilder生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。这种存储方式使得存储的字符串更少，因此拥有更高的效率和更少的存储空间。当我们想要连接两个字符串时进行的操作如下图：<br><img src="https://img-blog.csdnimg.cn/20201026121809565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在StringBuilder中如果数组的剩余容量，无法添加全部内容，则通过expandCapacity(int minimumCapacity)方法对value进行扩容，其中minimumCapacity = 原value长度 + append添加的内容长度。<br>1、扩大容量为原来的两倍 + 2，为什么要 + 2，而不是刚好两倍？<br>2、如果扩容之后，还是无法添加全部内容，则将 minimumCapacity 作为最终的容量大小；<br>3、利用 System.arraycopy 方法对原value数据进行复制；<br>在使用StringBuilder时，如果给定一个合适的初始值，可以避免由于char[]数组多次复制而导致的性能问题。</p><h2 id="（二）java-lag-StrigBuilder提供的函数"><a href="#（二）java-lag-StrigBuilder提供的函数" class="headerlink" title="（二）java.lag.StrigBuilder提供的函数"></a>（二）java.lag.StrigBuilder提供的函数</h2><p>一、创建Stringbuilder对象<br>StringBuilder strB = new StringBuilder();</p><p>1 append(String str)/append(Char c)<br>字符串连接<br>2 toString()<br>返回一个与构建起或缓冲器内容相同的字符串<br>3 appendcodePoint(int cp)<br>追加一个代码点，并将其转换为一个或两个代码单元并返回this<br>4 setCharAt(int i, char c)<br>将第 i 个代码单元设置为 c（可以理解为替换）char字符使用  ‘   ’<br>5 insert(int offset, String str)/insert(int offset, Char c)<br>在指定位置之前插入字符(串)<br>6 delete(int startIndex,int endIndex)<br>删除起始位置（含）到结尾位置（不含）之间的字符串</p><h1 id="三、StringBuffer"><a href="#三、StringBuffer" class="headerlink" title="三、StringBuffer"></a>三、StringBuffer</h1><p>StringBuffer和StringBuilder类似，提供了几乎同样的函数，不同的是：StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。</p><p>线程安全的实现是通过synchronized实现的，StringBuffer类中的方法都添加了synchronized关键字，也就是给这个方法添加了一个锁，用来保证线程安全。<br><img src="https://img-blog.csdnimg.cn/2020102612315195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcyODIzOA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>但是线程安全的实现必然会带来时间性能上的减弱。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Sting、StringBuilder、StringBuffer三者均用于实现字符串，但由于其字符串存储方法的不同，三者时间性能上从优到差为StringBuilder&gt;StringBuffer&gt;String。所以：<br>（1）如果要操作少量的数据用 String；<br>（2）多线程操作字符串缓冲区下操作大量数据 StringBuffer；<br>（3）单线程操作字符串缓冲区下操作大量数据 StringBuilder。</p>]]></content>
    
    
    <categories>
      
      <category>Java知识点总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-JAVA -基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
